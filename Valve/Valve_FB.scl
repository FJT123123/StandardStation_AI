FUNCTION_BLOCK "Valve_FB"

   TITLE = 阀门功能块
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 樊江涛
VERSION : 0.1
//功能说明：
// 1.安全联锁功能：最高优先级，确保系统安全，联锁时强制关闭阀门
// 2.自动/手动模式：
//   - 自动模式：根据自动命令和运行条件控制阀门
//   - 手动模式：支持面板按钮和辅助命令两种控制方式，带互锁功能
//     * 面板按钮：通过HMI.IN_xManualOpen和HMI.IN_xManualClose控制
//     * 辅助命令：通过Temp.IN_xManualCmd边沿触发控制，上升沿开启，下降沿关闭
// 3.开关状态反馈：
//   - 支持带传感器和无传感器两种模式（通过报警使能切换）
//   - 带传感器时检测开关到位信号，无传感器时仅根据输出状态判断
//   - 常开常闭阀控制逻辑：
//     * 常开阀(HMI.IN_xNormOpen=1)：Map.OUT_xActualOut=0表示开启状态
//     * 常闭阀(HMI.IN_xNormOpen=0)：Map.OUT_xActualOut=1表示开启状态
// 4.报警处理：
//   - 报警字(ALM.OUT_wALM)使用说明：
//     * Bit0：开阀超时报警，对应布尔量ALM.OUT_xOpenTimeout
//     * Bit1：关阀超时报警，对应布尔量ALM.OUT_xCloseTimeout
//     * Bit2：传感器故障报警，对应布尔量ALM.OUT_xSensorFault
//     * 可通过报警字快速判断所有报警状态，或使用对应布尔量单独处理
//   - 传感器故障报警：检测开关传感器状态矛盾
//   - 开关超时报警：动作超时检测和报警
//   - 报警使能(HMI.IN_xALMEnable)：
//     * TRUE：使用传感器信号判断开关到位状态，启用传感器故障和超时报警
//     * FALSE：仅使用输出状态判断开关到位，禁用所有报警功能
// 5.动作时间和计数：
//   - 记录阀门动作时间
//   - 开到位次数计数，支持复位，掉电保持
// 6.状态显示：
//   - 支持8种状态显示：初始、开到位、关到位、正在开、正在关、开阀故障、关阀故障、传感器故障
//   - 状态优先级（从高到低）：
//     1) 传感器故障（需报警使能）
//     2) 开关超时报警（需报警使能）
//     3) 开关到位状态
//     4) 开关中状态
//     5) 初始状态
// 输入变量
VAR_INPUT 
      IN_xSys_EDS : Bool;   // 安全联锁
      IN_xM_A : Bool;   // 自动1/手动0模式切换
      IN_xREST : Bool;   // 复位信号
   END_VAR

   // 输入输出变量（结构体）
   VAR_IN_OUT 
      Map : "UDT_Valve_Map";   // 阀门I/O映射
      Temp : "UDT_Valve_Temp";   // 阀门临时变量
      HMI : "UDT_Valve_HMI";   // HMI接口
      Keep : "UDT_Valve_Keep";   // 掉电保持数据
      ALM : "UDT_Valve_ALM";   // 报警信息
   END_VAR

   // 内部变量
   VAR 
      // 报警状态
      xSensorFault : Bool;   // 传感器故障状态
      xOpenTimeout : Bool;   // 开阀超时状态
      xCloseTimeout : Bool;   // 关阀超时状态
      
      // 计数和边沿检测
      xLastOpenOK : Bool;   // 开到位上升沿检测用
      xLastManualOpen : Bool;   // 手动开上升沿
      xLastManualClose : Bool;   // 手动关上升沿
      xLastManualCmd : Bool;    // 手动命令上升沿/下降沿检测
      xLastM_A : Bool;   // 自动/手动模式切换边沿检测
      
      // 定时器
      TON_Open{InstructionName := 'IEC_TIMER'; LibVersion := '1.0'}  : TON_TIME;   // 开阀延时
      TON_Close{InstructionName := 'IEC_TIMER'; LibVersion := '1.0'}  : TON_TIME;   // 关阀延时
      TON_Runtime{InstructionName := 'IEC_TIMER'; LibVersion := '1.0'}  : TON_TIME;   // 动作时间
      tRuntime : Time;   // 当前动作时间
   END_VAR

   // 常量定义
   VAR CONSTANT 
      VALVE_STATE_INIT : UInt := 0;   // 初始状态
      VALVE_STATE_CLOSED : UInt := 1;   // 已关闭
      VALVE_STATE_OPENED : UInt := 2;   // 已打开
      VALVE_STATE_OPENING : UInt := 3;   // 正在打开
      VALVE_STATE_CLOSING : UInt := 4;   // 正在关闭
      VALVE_STATE_CLOSE_FAULT : UInt := 5;   // 关阀故障
      VALVE_STATE_OPEN_FAULT : UInt := 6;   // 开阀故障
      VALVE_STATE_SENSOR_FAULT : UInt := 7;   // 传感器故障
   END_VAR


BEGIN
	    REGION 安全联锁处理/自动/手动模式切换
	        // 安全联锁处理，最高优先级
	        IF NOT #IN_xSys_EDS THEN
	            #Map.OUT_xActualOut := 0;
	            
	        ELSIF #IN_xM_A THEN
	            // 自动模式
	            IF #Temp.IN_xAutoCmd AND #Temp.IN_xOpenCondition THEN
	                #Map.OUT_xActualOut := NOT #HMI.IN_xNormOpen;
	            ELSIF NOT #Temp.IN_xAutoCmd AND #Temp.IN_xCloseCondition THEN
	                #Map.OUT_xActualOut := #HMI.IN_xNormOpen;
	            END_IF;
	        ELSIF #xLastM_A AND NOT #IN_xM_A THEN
	            // 自动切手动时，根据手动命令状态决定阀门状态
	            IF #Temp.IN_xManualCmd AND #Temp.IN_xOpenCondition THEN
	                #Map.OUT_xActualOut := NOT #HMI.IN_xNormOpen;
	                #xLastManualClose := FALSE;
	                #HMI.IN_xManualClose := FALSE;
	            ELSIF NOT #Temp.IN_xManualCmd AND #Temp.IN_xCloseCondition THEN
	                #Map.OUT_xActualOut := #HMI.IN_xNormOpen;
	                #xLastManualOpen := FALSE;
	                #HMI.IN_xManualOpen := FALSE;
	            END_IF;
	        ELSE
	            // 手动模式，使用RS触发器实现互锁
	            IF #HMI.IN_xManualOpen AND NOT #xLastManualOpen AND #Temp.IN_xOpenCondition THEN
	                // 开阀请求，同时清除关阀状态
	                #Map.OUT_xActualOut := NOT #HMI.IN_xNormOpen;
	                #xLastManualClose := FALSE;
	                #HMI.IN_xManualClose := FALSE;
	            ELSIF #HMI.IN_xManualClose AND NOT #xLastManualClose AND #Temp.IN_xCloseCondition THEN
	                // 关阀请求，同时清除开阀状态
	                #Map.OUT_xActualOut := #HMI.IN_xNormOpen;
	                #xLastManualOpen := FALSE;
	                #HMI.IN_xManualOpen := FALSE;
	                // 处理手动命令控制 - 使用上升沿和下降沿触发
	            ELSIF #Temp.IN_xManualCmd AND NOT #xLastManualCmd AND #Temp.IN_xOpenCondition THEN
	                // 手动命令上升沿触发开阀，同时清除关阀状态
	                #Map.OUT_xActualOut := NOT #HMI.IN_xNormOpen;
	                #xLastManualClose := FALSE;
	                #HMI.IN_xManualClose := FALSE;
	            ELSIF NOT #Temp.IN_xManualCmd AND #xLastManualCmd AND #Temp.IN_xCloseCondition THEN
	                // 手动命令下降沿触发关阀，同时清除开阀状态
	                #Map.OUT_xActualOut := #HMI.IN_xNormOpen;
	                #xLastManualOpen := FALSE;
	                #HMI.IN_xManualOpen := FALSE;
	            END_IF;
	            
	            // 更新边沿检测状态
	            #xLastManualOpen := #HMI.IN_xManualOpen;
	            #xLastManualClose := #HMI.IN_xManualClose;
	            #xLastManualCmd := #Temp.IN_xManualCmd;
	            #xLastM_A := #IN_xM_A;
	        END_IF;
	    END_REGION
	    
	    REGION 开关状态反馈处理
	        // 根据报警使能状态选择反馈信号来源
	        #Temp.OUT_xOpenOK := SEL(G := #Keep.IN_xALMEnable,
	                                 IN0 := (#Map.OUT_xActualOut <> #HMI.IN_xNormOpen),
	                                 IN1 := #Map.IN_xOpenFeedback AND (#Map.OUT_xActualOut <> #HMI.IN_xNormOpen));
	        #Temp.OUT_xCloseOK := SEL(G := #Keep.IN_xALMEnable,
	                                  IN0 := (#Map.OUT_xActualOut = #HMI.IN_xNormOpen),
	                                  IN1 := #Map.IN_xCloseFeedback AND (#Map.OUT_xActualOut = #HMI.IN_xNormOpen));
	    END_REGION
	    
	    REGION 报警处理
	        // 复位处理
	        IF #IN_xREST THEN
	            // 只有通过复位按钮才能复位报警状态
	            #xSensorFault := FALSE;
	            #xOpenTimeout := FALSE;
	            #xCloseTimeout := FALSE;
	        END_IF;
	        
	        IF #Keep.IN_xALMEnable THEN
	            // 传感器故障检测
	            IF (#Map.IN_xOpenFeedback AND #Map.IN_xCloseFeedback) OR
	                (NOT #Map.IN_xOpenFeedback AND NOT #Map.IN_xCloseFeedback) THEN
	                #xSensorFault := TRUE;
	            END_IF;
	            
	            // 超时报警处理
	            // 开阀超时检测
	            #TON_Open(IN := (#Map.OUT_xActualOut <> #HMI.IN_xNormOpen) AND NOT #Temp.OUT_xOpenOK,
	                      PT := #Keep.IN_tOpenTime);
	            IF #TON_Open.Q THEN
	                #xOpenTimeout := TRUE;
	            END_IF;
	            
	            // 关阀超时检测
	            #TON_Close(IN := (#Map.OUT_xActualOut = #HMI.IN_xNormOpen) AND NOT #Temp.OUT_xCloseOK,
	                       PT := #Keep.IN_tCloseTime);
	            IF #TON_Close.Q THEN
	                #xCloseTimeout := TRUE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 动作时间计算
	        // 只在阀门动作时计时
	        #TON_Runtime(IN := (#Map.OUT_xActualOut <> #HMI.IN_xNormOpen AND NOT #Temp.OUT_xOpenOK) OR
	                     (#Map.OUT_xActualOut = #HMI.IN_xNormOpen AND NOT #Temp.OUT_xCloseOK),
	                     PT := T#24H);
	        IF #TON_Runtime.IN THEN
	            #tRuntime := #TON_Runtime.ET;
	        END_IF;
	    END_REGION
	    
	    REGION 报警状态更新
	        // 报警字和报警布尔量更新
	        // 先将报警字复位为0
	        #ALM.OUT_wALM := 0;
	        
	        // Bit0: 开阀超时报警
	        #ALM.OUT_wALM.%X0 := #xOpenTimeout;
	        #ALM.OUT_xOpenTimeout := #xOpenTimeout;
	        // Bit1: 关阀超时报警
	        #ALM.OUT_wALM.%X1 := #xCloseTimeout;
	        #ALM.OUT_xCloseTimeout := #xCloseTimeout;
	        // Bit2: 传感器故障报警
	        #ALM.OUT_wALM.%X2 := #xSensorFault;
	        #ALM.OUT_xSensorFault := #xSensorFault;
	    END_REGION
	    
	    REGION 计数功能
	        // 使用开到位上升沿计数
	        IF #HMI.IN_xCounterReset THEN
	            #Keep.INOUT_udiCount := 0;
	        ELSE
	            IF #Temp.OUT_xOpenOK AND NOT #xLastOpenOK THEN
	                #Keep.INOUT_udiCount := #Keep.INOUT_udiCount + 1;
	            END_IF;
	        END_IF;
	        #xLastOpenOK := #Temp.OUT_xOpenOK;
	    END_REGION
	    
	    REGION 状态字更新
	        // 报警使能无效时清除报警状态
	        IF NOT #Keep.IN_xALMEnable THEN
	            #xSensorFault := FALSE;
	            #xOpenTimeout := FALSE;
	            #xCloseTimeout := FALSE;
	        END_IF;
	        
	        // 状态字处理逻辑，按优先级排序
	        IF #xSensorFault AND #Keep.IN_xALMEnable THEN
	            #HMI.OUT_uiState := #VALVE_STATE_SENSOR_FAULT;
	        ELSIF (#xOpenTimeout OR #xCloseTimeout) AND #Keep.IN_xALMEnable THEN
	            IF #xOpenTimeout THEN
	                #HMI.OUT_uiState := #VALVE_STATE_OPEN_FAULT;
	            ELSE
	                #HMI.OUT_uiState := #VALVE_STATE_CLOSE_FAULT;
	            END_IF;
	        ELSIF #Temp.OUT_xOpenOK THEN
	            #HMI.OUT_uiState := #VALVE_STATE_OPENED;
	        ELSIF #Temp.OUT_xCloseOK THEN
	            #HMI.OUT_uiState := #VALVE_STATE_CLOSED;
	        ELSIF #Map.OUT_xActualOut <> #HMI.IN_xNormOpen THEN
	            #HMI.OUT_uiState := #VALVE_STATE_OPENING;
	        ELSIF #Map.OUT_xActualOut = #HMI.IN_xNormOpen THEN
	            #HMI.OUT_uiState := #VALVE_STATE_CLOSING;
	        ELSE
	            #HMI.OUT_uiState := #VALVE_STATE_INIT;
	        END_IF;
	    END_REGION
END_FUNCTION_BLOCK

