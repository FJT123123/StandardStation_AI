TYPE "UDT_Valve_Map"
VERSION : 0.1
   STRUCT
      IN_xOpenFeedback : Bool;   // 传感器开
      IN_xCloseFeedback : Bool;   // 传感器关
      OUT_xActualOut : Bool;   // 阀门控制
   END_STRUCT;

END_TYPE

TYPE "UDT_Valve_Variable"
VERSION : 0.1
   STRUCT
      IN_xAutoCmd : Bool;   // 自动模式开阀
      OUT_xOpenOK : Bool;   // 开到位
      OUT_xCloseOK : Bool;   // 关到位
   END_STRUCT;

END_TYPE

TYPE "UDT_Valve_HMI"
VERSION : 0.1
   STRUCT
      IN_xNormOpen : Bool;   // 常开常闭阀选择/常开为1，常闭为0
      IN_xALMEnable : Bool := TRUE;   // 报警使能
      IN_xManualOpen : Bool;   // 手动开
      IN_xManualClose : Bool;   // 手动关
      IN_xCounterReset : Bool;   // 计数复位
      IN_xOpenCondition : Bool := TRUE;   // 开阀运行条件
      IN_xCloseCondition : Bool := TRUE;   // 关阀运行条件
      OUT_uiState : UInt;   // 状态字(0=初始状态,1=已关闭,2=已打开,3=正在打开,4=正在关闭,5=关阀故障,6=开阀故障,7=传感器故障)
   END_STRUCT;

END_TYPE

TYPE "UDT_Valve_Retain"
VERSION : 0.1
   STRUCT
      IN_tOpenTime : Time := T#10S;
      IN_tCloseTime : Time := T#10S;
      INOUT_udiCount : UDInt;   // 计次
   END_STRUCT;

END_TYPE

TYPE "UDT_Valve_ALM"
VERSION : 0.1
   STRUCT
      OUT_wALM : Word;   // 报警字 (Bit0=开阀超时报警, Bit1=关阀超时报警, Bit2=传感器故障报警)
      OUT_xSensorFault : Bool;   // 传感器故障
      OUT_xOpenTimeout : Bool;   // 开阀超时
      OUT_xCloseTimeout : Bool;   // 关阀超时
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "Valve_FB"
TITLE = 阀门功能块
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 樊江涛
VERSION : 0.1
//写每次更新的内容
   VAR_INPUT 
      IN_xSys_EDS : Bool;   // 安全联锁
      IN_xM_A : Bool;   // 自动1/手动0模式切换
      IN_xREST : Bool;
   END_VAR

   VAR_IN_OUT 
      Map : "UDT_Valve_Map";
      Variable : "UDT_Valve_Variable";
      HMI : "UDT_Valve_HMI";
      "Retain" : "UDT_Valve_Retain";
      ALM : "UDT_Valve_ALM";
   END_VAR

   VAR 
      xSensorFault : Bool;   // 传感器故障状态
      xOpenTimeout : Bool;   // 开阀超时状态
      xCloseTimeout : Bool;   // 关阀超时状态
      LastOpenOK : Bool;   // 开到位上升沿检测用
      TON_Open {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;   // 开阀延时
      TON_Close {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;   // 关阀延时
      TON_Action {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;   // 动作时间
      xLastManualOpen : Bool;   // 手动开上升沿
      xLastManualClose : Bool;   // 手动关上升沿
      tActionTime : Time;   // 当前动作时间
   END_VAR

   VAR CONSTANT 
      VALVE_STATE_INIT : UInt := 0;   // 初始状态
      VALVE_STATE_CLOSED : UInt := 1;   // 已关闭
      VALVE_STATE_OPENED : UInt := 2;   // 已打开
      VALVE_STATE_OPENING : UInt := 3;   // 正在打开
      VALVE_STATE_CLOSING : UInt := 4;   // 正在关闭
      VALVE_STATE_CLOSE_FAULT : UInt := 5;   // 关阀故障
      VALVE_STATE_OPEN_FAULT : UInt := 6;   // 开阀故障
      VALVE_STATE_SENSOR_FAULT : UInt := 7;   // 传感器故障
   END_VAR


BEGIN
	    REGION 安全联锁处理/自动/手动模式切换
	        // 安全联锁处理，最高优先级
	        IF NOT #IN_xSys_EDS THEN
	            #Map.OUT_xActualOut := 0;
	            
	        ELSIF #IN_xM_A THEN
	            // 自动模式
	            IF #Variable.IN_xAutoCmd AND #HMI.IN_xOpenCondition THEN
	                #Map.OUT_xActualOut := NOT #HMI.IN_xNormOpen;
	            ELSIF NOT #Variable.IN_xAutoCmd AND #HMI.IN_xCloseCondition THEN
	                #Map.OUT_xActualOut := #HMI.IN_xNormOpen;
	            END_IF;
	        ELSE
	            // 手动模式，使用RS触发器实现互锁
	            IF #HMI.IN_xManualOpen AND NOT #xLastManualOpen AND #HMI.IN_xOpenCondition THEN
	                // 开阀请求，同时清除关阀状态
	                #Map.OUT_xActualOut := NOT #HMI.IN_xNormOpen;
	                #xLastManualClose := FALSE;
	                #HMI.IN_xManualClose := FALSE;
	            ELSIF #HMI.IN_xManualClose AND NOT #xLastManualClose AND #HMI.IN_xCloseCondition THEN
	                // 关阀请求，同时清除开阀状态
	                #Map.OUT_xActualOut := #HMI.IN_xNormOpen;
	                #xLastManualOpen := FALSE;
	                #HMI.IN_xManualOpen := FALSE;
	            END_IF;
	            // 更新边沿检测状态
	            IF NOT #HMI.IN_xManualOpen THEN
	                #xLastManualOpen := FALSE;
	            END_IF;
	            IF NOT #HMI.IN_xManualClose THEN
	                #xLastManualClose := FALSE;
	            END_IF;
	            IF #HMI.IN_xManualOpen THEN
	                #xLastManualOpen := TRUE;
	            END_IF;
	            IF #HMI.IN_xManualClose THEN
	                #xLastManualClose := TRUE;
	            END_IF;
	        END_IF
	        ;
	    END_REGION
	    
	    REGION 开关状态反馈处理
	        // 开关状态反馈处理
	        // 根据报警使能状态选择反馈信号来源
	        #Variable.OUT_xOpenOK := SEL(G := #HMI.IN_xALMEnable,
	                                     IN0 := (#Map.OUT_xActualOut <> #HMI.IN_xNormOpen),
	                                     IN1 := #Map.IN_xOpenFeedback AND (#Map.OUT_xActualOut <> #HMI.IN_xNormOpen));
	        #Variable.OUT_xCloseOK := SEL(G := #HMI.IN_xALMEnable,
	                                      IN0 := (#Map.OUT_xActualOut = #HMI.IN_xNormOpen),
	                                      IN1 := #Map.IN_xCloseFeedback AND (#Map.OUT_xActualOut = #HMI.IN_xNormOpen));
	    END_REGION
	    
	    REGION 报警处理
	        // 报警处理
	        // 集中处理所有报警相关的逻辑
	        IF #IN_xREST THEN
	            // 只有通过复位按钮才能复位报警状态
	            #xSensorFault := FALSE;
	            #xOpenTimeout := FALSE;
	            #xCloseTimeout := FALSE;
	        END_IF;
	        
	        IF #HMI.IN_xALMEnable THEN
	            // 1. 传感器故障检测
	            // 开关传感器同时为1或同时为0时，表示传感器故障
	            IF (#Map.IN_xOpenFeedback AND #Map.IN_xCloseFeedback) OR
	                (NOT #Map.IN_xOpenFeedback AND NOT #Map.IN_xCloseFeedback) THEN
	                #xSensorFault := TRUE;
	            END_IF;
	            
	            // 2. 超时报警处理
	            // 开阀超时，使用TON定时器，考虑常开常闭阀的影响
	            #TON_Open(IN := (#Map.OUT_xActualOut <> #HMI.IN_xNormOpen) AND NOT #Variable.OUT_xOpenOK,
	                      PT := #Retain.IN_tOpenTime);
	            IF #TON_Open.Q THEN
	                #xOpenTimeout := TRUE;
	            END_IF;
	            
	            // 关阀超时，使用TON定时器，考虑常开常闭阀的影响
	            #TON_Close(IN := (#Map.OUT_xActualOut = #HMI.IN_xNormOpen) AND NOT #Variable.OUT_xCloseOK,
	                       PT := #Retain.IN_tCloseTime);
	            IF #TON_Close.Q THEN
	                #xCloseTimeout := TRUE;
	            END_IF;
	        END_IF;
	    END_REGION
	    
	    REGION 动作时间计算
	        // 动作时间计算 - 只在阀门动作时计时
	        #TON_Action(IN := (#Map.OUT_xActualOut <> #HMI.IN_xNormOpen AND NOT #Variable.OUT_xOpenOK) OR
	                    (#Map.OUT_xActualOut = #HMI.IN_xNormOpen AND NOT #Variable.OUT_xCloseOK),
	                    PT := T#24H);
	        IF #TON_Action.IN THEN
	            #tActionTime := #TON_Action.ET;
	        END_IF;
	    END_REGION
	    
	    REGION 报警状态更新
	        // 3. 报警字和报警布尔量更新
	        // Bit0: 开阀超时报警
	        #ALM.OUT_wALM.%X0 := #xOpenTimeout;
	        #ALM.OUT_xOpenTimeout := #xOpenTimeout;
	        // Bit1: 关阀超时报警
	        #ALM.OUT_wALM.%X1 := #xCloseTimeout;
	        #ALM.OUT_xCloseTimeout := #xCloseTimeout;
	        // Bit2: 传感器故障报警
	        #ALM.OUT_wALM.%X2 := #xSensorFault;
	        #ALM.OUT_xSensorFault := #xSensorFault;
	    END_REGION
	    
	    REGION 计数功能
	        // 计数功能，使用开到位上升沿计数
	        IF #HMI.IN_xCounterReset THEN
	            #Retain.INOUT_udiCount := 0;
	        ELSE
	            IF #Variable.OUT_xOpenOK AND NOT #LastOpenOK THEN
	                #Retain.INOUT_udiCount := #Retain.INOUT_udiCount + 1;
	            END_IF;
	        END_IF;
	        #LastOpenOK := #Variable.OUT_xOpenOK;
	    END_REGION
	    
	    REGION 状态字更新
	        // 状态字更新 - 调整优先级顺序
	        // 报警使能无效时清除报警状态
	        IF NOT #HMI.IN_xALMEnable THEN
	            #xSensorFault := FALSE;
	            #xOpenTimeout := FALSE;
	            #xCloseTimeout := FALSE;
	        END_IF;
	        
	        // 统一的状态字处理逻辑，按优先级排序
	        IF #xSensorFault AND #HMI.IN_xALMEnable THEN
	            #HMI.OUT_uiState := #VALVE_STATE_SENSOR_FAULT;
	        ELSIF (#xOpenTimeout OR #xCloseTimeout) AND #HMI.IN_xALMEnable THEN
	            IF #xOpenTimeout THEN
	                #HMI.OUT_uiState := #VALVE_STATE_OPEN_FAULT;
	            ELSE
	                #HMI.OUT_uiState := #VALVE_STATE_CLOSE_FAULT;
	            END_IF;
	        ELSIF #Variable.OUT_xOpenOK THEN
	            #HMI.OUT_uiState := #VALVE_STATE_OPENED;
	        ELSIF #Variable.OUT_xCloseOK THEN
	            #HMI.OUT_uiState := #VALVE_STATE_CLOSED;
	        ELSIF #Map.OUT_xActualOut <> #HMI.IN_xNormOpen THEN
	            #HMI.OUT_uiState := #VALVE_STATE_OPENING;
	        ELSIF #Map.OUT_xActualOut = #HMI.IN_xNormOpen THEN
	            #HMI.OUT_uiState := #VALVE_STATE_CLOSING;
	        ELSE
	            #HMI.OUT_uiState := #VALVE_STATE_INIT;
	        END_IF;
	    END_REGION
END_FUNCTION_BLOCK

