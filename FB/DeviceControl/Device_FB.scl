FUNCTION_BLOCK "Device_FB"
TITLE = 设备控制功能块
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
//
//功能说明：
//1. 本功能块用于控制设备的启停，支持自动/手动模式切换
//2. 具备启动/停止超时检测、设备报警检测功能
//3. 支持运行时间统计
//4. 提供启动/停止对方设备的脉冲信号
//
//使用说明：
//1. 输入参数：
//   - IN_xSys_EDS：安全联锁信号，为1时强制停止设备
//   - IN_xM_A：模式选择，1为自动模式，0为手动模式
//   - IN_xREST：复位信号，用于清除报警
//
//2. 设备控制：
//   - 自动模式：通过IN_xAutoCmd控制设备
//   - 手动模式：可通过HMI界面按钮或IN_xManualCmd控制
//
//3. 报警功能：
//   - 启动超时：设备启动后，在设定时间内未收到启动反馈
//   - 停止超时：设备停止后，在设定时间内未停止到位
//   - 设备报警：来自设备的报警信号
//
//4. 运行时间：
//   - 统计设备每次启动后的运行时间（分钟）
   VAR_INPUT 
      IN_xSys_EDS : Bool;   // 安全联锁
      IN_xM_A : Bool;   // 自动1/手动0模式切换
      IN_xREST : Bool;   // 复位信号
   END_VAR

   VAR_IN_OUT 
      Map : "UDT_Device_Map";   // 设备I/O映射
      Temp : "UDT_Device_Temp";   // 设备临时变量
      HMI : "UDT_Device_HMI";   // HMI接口
      Keep : "UDT_Device_Keep";   // 掉电保持数据
      ALM : "UDT_Device_ALM";   // 报警信息 报警状态
   END_VAR

   VAR 
      xStartTimeout : Bool;   // 启动超时状态
      xStopTimeout : Bool;   // 停止超时状态 边沿检测
      xLastManualStart : Bool;   // 手动启动上升沿
      xLastManualStop : Bool;   // 手动停止上升沿
      xLastManualCmd : Bool;   // 手动命令上升沿/下降沿检测
      xLastM_A : Bool;   // 自动/手动模式切换边沿检测
      xLastActualOut : Bool;   // 上一周期设备控制状态 定时器
      TON_Start {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 启动延时
      TON_Stop {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 停止延时
      TON_Runtime {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 运行时间
      TON_StartPulse {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 启动脉冲定时器
      TON_StopPulse {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 停止脉冲定时器
   END_VAR

   VAR CONSTANT 
      DEVICE_STATE_INIT : UInt := 0;   // 初始状态
      DEVICE_STATE_STOPPED : UInt := 1;   // 已停止
      DEVICE_STATE_STARTED : UInt := 2;   // 已启动
      DEVICE_STATE_STARTING : UInt := 3;   // 正在启动
      DEVICE_STATE_STOPPING : UInt := 4;   // 正在停止
      DEVICE_STATE_STOP_FAULT : UInt := 5;   // 停止故障
      DEVICE_STATE_START_FAULT : UInt := 6;   // 启动故障
      DEVICE_STATE_DEVICE_FAULT : UInt := 7;   // 设备报警
   END_VAR


BEGIN
	    REGION 安全联锁处理/自动/手动模式切换
	        // 安全联锁处理，最高优先级
	        // 增加报警联锁：任意报警发生时都需要关闭设备
	        IF #IN_xSys_EDS OR #ALM.OUT_wALM <> 0 THEN
	            #Map.OUT_xActualOut := 0;
	            
	        ELSIF #IN_xM_A THEN
	            // 自动模式
	            IF #Temp.IN_xAutoCmd AND #Temp.IN_xStartCondition THEN
	                #Map.OUT_xActualOut := 1;
	            ELSE
	                #Map.OUT_xActualOut := 0;
	            END_IF;
	        ELSIF #xLastM_A AND NOT #IN_xM_A THEN
	            // 自动切手动时，根据手动命令状态决定设备状态
	            IF #Temp.IN_xManualCmd AND #Temp.IN_xStartCondition THEN
	                #Map.OUT_xActualOut := 1;
	                #HMI.IN_xManualStop := FALSE;
	            ELSE
	                #Map.OUT_xActualOut := 0;
	                #HMI.IN_xManualStart := FALSE;
	            END_IF;
	        ELSE
	            // 手动模式，使用RS触发器实现互锁
	            IF #HMI.IN_xManualStart AND NOT #xLastManualStart AND #Temp.IN_xStartCondition THEN
	                #Map.OUT_xActualOut := 1;
	                #HMI.IN_xManualStop := FALSE;
	            ELSIF #HMI.IN_xManualStop AND NOT #xLastManualStop THEN
	                #Map.OUT_xActualOut := 0;
	                #HMI.IN_xManualStart := FALSE;
	                // 处理手动命令控制
	            ELSIF #Temp.IN_xManualCmd AND NOT #xLastManualCmd AND #Temp.IN_xStartCondition THEN
	                #Map.OUT_xActualOut := 1;
	                #HMI.IN_xManualStop := FALSE;
	            ELSIF NOT #Temp.IN_xManualCmd AND #xLastManualCmd THEN
	                #Map.OUT_xActualOut := 0;
	                #HMI.IN_xManualStart := FALSE;
	            END_IF;
	            
	            // 更新边沿检测状态
	            #xLastManualStart := #HMI.IN_xManualStart;
	            #xLastManualStop := #HMI.IN_xManualStop;
	            #xLastManualCmd := #Temp.IN_xManualCmd;
	        END_IF;
	        #xLastM_A := #IN_xM_A;
	        
	        // 处理对方设备的启动和停止信号
	        // 检测设备控制状态变化，生成启动和停止脉冲信号
	        IF #Map.OUT_xActualOut AND NOT #xLastActualOut THEN
	            // 设备从停止到启动，发出启动信号
	            #Map.OUT_xStartDevice := 1;
	            #TON_StartPulse.IN := TRUE;
	            #TON_StartPulse.PT := T#1S;
	        ELSIF NOT #Map.OUT_xActualOut AND #xLastActualOut THEN
	            // 设备从启动到停止，发出停止信号
	            #Map.OUT_xStopDevice := 1;
	            #TON_StopPulse.IN := TRUE;
	            #TON_StopPulse.PT := T#1S;
	        END_IF;
	        
	        // 1秒后自动复位启动和停止信号
	        IF #TON_StartPulse.Q THEN
	            #Map.OUT_xStartDevice := 0;
	            #TON_StartPulse.IN := FALSE;
	        END_IF;
	        
	        IF #TON_StopPulse.Q THEN
	            #Map.OUT_xStopDevice := 0;
	            #TON_StopPulse.IN := FALSE;
	        END_IF;
	        
	        // 更新上一周期设备控制状态
	        #xLastActualOut := #Map.OUT_xActualOut;
	    END_REGION
	    
	    REGION 启停状态反馈处理
	        #Temp.OUT_xStartOK := #Map.IN_xStartFeedback AND #Map.OUT_xActualOut;
	        #Temp.OUT_xStopOK := NOT #Map.OUT_xActualOut AND NOT #Map.IN_xStartFeedback;
	    END_REGION
	    
	    REGION 报警处理
	        // 复位处理
	        IF #IN_xREST THEN
	            #xStartTimeout := FALSE;
	            #xStopTimeout := FALSE;
	            // 复位时也清除设备报警
	            #ALM.OUT_xDeviceAlarm := FALSE;
	        END_IF;
	        
	        // 设备报警直接处理
	        IF #Map.IN_xAlarmFeedback AND #Keep.IN_xAlarmEnable THEN
	            #ALM.OUT_xDeviceAlarm := TRUE;
	        ELSE
	            #ALM.OUT_xDeviceAlarm := FALSE;
	        END_IF;
	        
	        // 启动超时检测
	        #TON_Start.IN := #Map.OUT_xActualOut AND NOT #Temp.OUT_xStartOK;
	        #TON_Start.PT := #Keep.IN_tStartTime;
	        IF #TON_Start.Q AND #Keep.IN_xAlarmEnable THEN
	            #xStartTimeout := TRUE;
	        END_IF;
	        
	        // 停止超时检测
	        #TON_Stop.IN := NOT #Map.OUT_xActualOut AND NOT #Temp.OUT_xStopOK;
	        #TON_Stop.PT := #Keep.IN_tStopTime;
	        IF #TON_Stop.Q AND #Keep.IN_xAlarmEnable THEN
	            #xStopTimeout := TRUE;
	        END_IF;
	    END_REGION
	    
	    REGION 运行时间计算
	        #TON_Runtime.IN := #Temp.OUT_xStartOK;
	        #TON_Runtime.PT := T#24H;
	        IF #Temp.OUT_xStartOK THEN
	            #Keep.OUT_tCurrentRun := DINT_TO_UDINT(TIME_TO_DINT(#TON_Runtime.ET) / 60000); // 转换为分钟
	        ELSE
	            #TON_Runtime.IN := FALSE;
	            #Keep.OUT_tCurrentRun := 0;
	        END_IF;
	    END_REGION
	    
	    REGION 报警状态更新
	        // 报警字和报警布尔量更新
	        // 先将报警字复位为0
	        #ALM.OUT_wALM := 0;
	        
	        #ALM.OUT_wALM.%X0 := #xStartTimeout;
	        #ALM.OUT_xStartTimeout := #xStartTimeout;
	        #ALM.OUT_wALM.%X1 := #xStopTimeout;
	        #ALM.OUT_xStopTimeout := #xStopTimeout;
	        #ALM.OUT_wALM.%X2 := #ALM.OUT_xDeviceAlarm;
	    END_REGION
	    
	    REGION 状态字更新
	        IF #ALM.OUT_xDeviceAlarm THEN
	            #HMI.OUT_uiState := #DEVICE_STATE_DEVICE_FAULT;
	        ELSIF #xStartTimeout THEN
	            #HMI.OUT_uiState := #DEVICE_STATE_START_FAULT;
	        ELSIF #xStopTimeout THEN
	            #HMI.OUT_uiState := #DEVICE_STATE_STOP_FAULT;
	        ELSIF #Temp.OUT_xStartOK THEN
	            #HMI.OUT_uiState := #DEVICE_STATE_STARTED;
	        ELSIF #Temp.OUT_xStopOK THEN
	            #HMI.OUT_uiState := #DEVICE_STATE_STOPPED;
	        ELSIF #Map.OUT_xActualOut THEN
	            #HMI.OUT_uiState := #DEVICE_STATE_STARTING;
	        ELSIF NOT #Map.OUT_xActualOut THEN
	            #HMI.OUT_uiState := #DEVICE_STATE_STOPPING;
	        ELSE
	            #HMI.OUT_uiState := #DEVICE_STATE_INIT;
	        END_IF;
	    END_REGION
END_FUNCTION_BLOCK

