FUNCTION_BLOCK "ModbusRTU_FB"
   { S7_Optimized_Access := 'TRUE' }
AUTHOR : 樊江涛
FAMILY : MODBUS
NAME : ModbusRTU_FB
VERSION : 0.1
VAR_INPUT 
      IN_Config : "UDT_ModbusRTU_Config";   // Modbus RTU 通信配置
   END_VAR

   VAR_IN_OUT 
      INOUT_datas : Array[*] OF "UDT_Modbus_Config";   // 通信数据区
      INOUT_wSTATUS : Array[*] OF "UDT_Modbus_ALM";
   END_VAR

   VAR 
      statLower : DInt;   // 数据区数组下标下限
      statUpper : DInt;   // 数据区数组下标上限
      statNo : DInt;   // 当前访问的数据区数组下标
      statByteString : Array[0..249] OF Byte;   // DATA_PTR 250 字节数组
      statDone : Bool;   // 初始化标志位
      instModbusCommLoad{InstructionName := 'Modbus_Comm_Load_FB_640_S71200'; LibVersion := '5.0'}  : Modbus_Comm_Load;   // Modbus_Comm_Load 背景
      instModbusMaster{InstructionName := 'Modbus_Master_FB_641_S71200'; LibVersion := '5.0'}  : Modbus_Master;   // Modbus_Master 背景
      tempError {EXTERNALACCESSIBLE := 'False'; EXTERNALVISIBLE := 'False'; EXTERNALWRITABLE := 'False'} : Word;   // 指令错误代码
   END_VAR

   VAR_TEMP 
      tempVariant : Variant;   // DB_ANY_TO_VARIANT  转换后的指针
      tempPos : DInt;   // （反）序列化的 POS 参数
   END_VAR


BEGIN
	//修改初始化通信模式为 4，即 RS485
	#instModbusCommLoad.MODE := 4;
	//初始化 Modbus RTU
	#instModbusCommLoad(REQ := #IN_Config.xReq,
	                    "PORT" := #IN_Config.hwPort,
	                    BAUD := #IN_Config.udiBaud,
	                    PARITY := #IN_Config.uiParity,
	                    RESP_TO := #IN_Config.uiRespTo,
	                    MB_DB := #instModbusMaster.MB_DB);
	
	//当初始化完成，记录数据区数组下标上下限，为当前访问的数据区数组下标赋值，初始化标志位置位
	IF #instModbusCommLoad.DONE
	THEN
	    #statLower := LOWER_BOUND(ARR := #INOUT_datas, DIM := 1);
	    #statUpper := UPPER_BOUND(ARR := #INOUT_datas, DIM := 1);
	    #statNo := #statLower;
	    #statDone := TRUE;
	END_IF;
	//初始化没有完成时跳过下面程序
	IF NOT #statDone
	THEN
	    RETURN;
	END_IF;
	
	//如果 Modbus_Master 没有请求，说明刚刚结束一个访问或准备第一次访问
	IF NOT #instModbusMaster.REQ
	THEN
	    //如果当前访问的数据区模式是 1，则需要向从站写数据
	    IF #INOUT_datas[#statNo].mode = 1
	    THEN
	        //将数据区的 DB_ANY 元素转化为 tempVariant 这个 Variant 类型指针
	        #tempVariant := DB_ANY_TO_VARIANT(in := #INOUT_datas[#statNo].instrument, err => #INOUT_wSTATUS[#statNo].ConversionError);
	        //为序列化指令 POS 参数赋初始值 0
	        #tempPos := 0;
	        //执行序列化指令，将 tempVariant 指针指向的变量序列化到 staticByteString 这个字节数组
	        #INOUT_wSTATUS[#statNo].DeserializeStatus := Serialize(SRC_VARIABLE := #tempVariant, DEST_ARRAY => #statByteString, POS := #tempPos);
	    END_IF;
	    //触发新的 Modbus_Master 请求
	    #instModbusMaster.REQ := TRUE;
	END_IF;
	
	//如果 Modbus_Master 完成
	IF #instModbusMaster.DONE
	THEN
	    //如果当前访问的数据区模式是 0，则需要从从站读数据
	    IF #INOUT_datas[#statNo].mode = 0
	    THEN
	        //将数据区的 DB_ANY 元素转化为 tempVariant 这个 Variant 类型指针
	        #tempVariant := DB_ANY_TO_VARIANT(in := #INOUT_datas[#statNo].instrument, err => #INOUT_wSTATUS[#statNo].ConversionError);
	        //为反序列化指令 POS 参数赋初始值 0
	        #tempPos := 0;
	        //执行反序列化指令，将读取到的 staticByteString 这个字节数组反序列化到 tempVariant 指针指向区域 
	        #INOUT_wSTATUS[#statNo].DeserializeStatus := Deserialize(SRC_ARRAY := #statByteString, DEST_VARIABLE => #tempVariant, POS := #tempPos);
	        // #INOUT_datas[#statNo].instrument := VARIANT_TO_DB_ANY(in := #tempVariant, err => #tempError);
	        
	        
	    END_IF;
	    //当前访问的数据区数组下标如果没到上限，则继续向上加一，否则回到下限
	END_IF;
	//如果 Modbus_Master 完成或者错误
	IF #instModbusMaster.DONE OR #instModbusMaster.ERROR
	THEN
	    //复位 Modbus_Master 请求
	    #instModbusMaster.REQ := FALSE;
	    IF #statNo < #statUpper
	    THEN
	        #statNo += 1;
	    ELSIF #statNo = #statUpper
	    THEN
	        #statNo := #statLower;
	    END_IF;
	END_IF;
	
	//调用 Modbus_Master 指令，为参数赋值通信数据区的数组元素
	#instModbusMaster(MB_ADDR := #INOUT_datas[#statNo].mbAddr,
	                  MODE := #INOUT_datas[#statNo].mode,
	                  DATA_ADDR := #INOUT_datas[#statNo].dataAddr,
	                  DATA_LEN := #INOUT_datas[#statNo].dataLen,
	                  DATA_PTR := #statByteString,
	                  STATUS => #INOUT_wSTATUS[#statNo].ModbusStatus
	);
	
	
END_FUNCTION_BLOCK