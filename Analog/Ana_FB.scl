FUNCTION_BLOCK "Ana_FB"
TITLE = 模拟量功能块
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 樊江涛
VERSION : 0.1
//功能说明：
// 1.标定处理功能：
//   - 支持三路传感器输入，可选择3取2中值或单路输入
//   - 支持4-20mA电流信号转换，具备除零保护
//   - 支持原始值到工程值的线性转换
// 2.自动/手动模式：
//   - 自动模式：使用传感器实际值
//   - 手动模式：使用手动设定值
// 3.报警功能：
//   - 支持高高、高、低、低低四级报警，高高和低低报警需手动复位
//   - 高和低报警支持自动复位，含死区处理
//   - 支持传感器故障报警
//   - 支持报警使能和报警延时，每种报警类型有独立延时定时器
//   - 支持报警屏蔽功能
//   - 报警状态可通过HMI工程值和状态字监控
   VAR_INPUT 
      IN_xALMREST : Bool;   // 复位信号
   END_VAR

   VAR_IN_OUT 
      Map : "UDT_Ana_Map";   // 模拟量I/O映射
      Temp : "UDT_Ana_Temp";   // 模拟量临时变量
      HMI : "UDT_Ana_HMI";   // HMI接口
      Keep : "UDT_Ana_Keep";   // 掉电保持数据
      ALM : "UDT_Ana_ALM";   // 报警信息
      PreAlarm : "UDT_Ana_PreAlarm";   // 预警信息
   END_VAR

   VAR 
      AlarmTimer {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 报警延时定时器
      RawValue : Int;   // 3取2后的原始值
      HHAlarmTimer {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 高高报警延时定时器
      LLAlarmTimer {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 低低报警延时定时器
      HAlarmTimer {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 高报警延时定时器
      LAlarmTimer {InstructionName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;   // 低报警延时定时器 状态常量定义
   END_VAR

   VAR CONSTANT 
      ANA_STATE_INIT : UInt := 0;   // 初始状态
      ANA_STATE_NORMAL : UInt := 1;   // 正常状态
      ANA_STATE_HH_ALARM : UInt := 2;   // 高高报警
      ANA_STATE_H_ALARM : UInt := 3;   // 高报警
      ANA_STATE_L_ALARM : UInt := 4;   // 低报警
      ANA_STATE_LL_ALARM : UInt := 5;   // 低低报警
      ANA_STATE_SENSOR_FAULT : UInt := 6;   // 传感器故障
   END_VAR


BEGIN
	    REGION 传感器故障检测
	        // 传感器故障检测已移至报警字和状态字更新区域
	    END_REGION
	    
	    REGION 电流值计算
	        // 计算4-20mA电流值//
	        IF (#Keep.IN_RawHigh - #Keep.IN_RawLow) <> 0 THEN
	            #Temp.OUT_RawCurrent1 := INT_TO_REAL(#Map.IN_RawValue1 - #Keep.IN_RawLow) * 16.0 / INT_TO_REAL(#Keep.IN_RawHigh - #Keep.IN_RawLow) + 4.0;
	            #Temp.OUT_RawCurrent2 := INT_TO_REAL(#Map.IN_RawValue2 - #Keep.IN_RawLow) * 16.0 / INT_TO_REAL(#Keep.IN_RawHigh - #Keep.IN_RawLow) + 4.0;
	            #Temp.OUT_RawCurrent3 := INT_TO_REAL(#Map.IN_RawValue3 - #Keep.IN_RawLow) * 16.0 / INT_TO_REAL(#Keep.IN_RawHigh - #Keep.IN_RawLow) + 4.0;
	        ELSE
	            // 防止除零错误，设置为默认值
	            #Temp.OUT_RawCurrent1 := 4.0;  // 最小电流值
	            #Temp.OUT_RawCurrent2 := 4.0;
	            #Temp.OUT_RawCurrent3 := 4.0;
	        END_IF;
	    END_REGION
	    
	    REGION 3取2中值选择
	        IF #Temp.IN_Enable3Take2 THEN
	            // 使用更高效的算法计算三个传感器的中值
	            // 先比较前两个值
	            IF #Map.IN_RawValue1 > #Map.IN_RawValue2 THEN
	                // 如果Value1 > Value2，比较Value2和Value3
	                IF #Map.IN_RawValue2 > #Map.IN_RawValue3 THEN
	                    #RawValue := #Map.IN_RawValue2; // Value2是中值
	                ELSIF #Map.IN_RawValue1 > #Map.IN_RawValue3 THEN
	                    #RawValue := #Map.IN_RawValue3; // Value3是中值
	                ELSE
	                    #RawValue := #Map.IN_RawValue1; // Value1是中值
	                END_IF;
	            ELSE
	                // 如果Value1 <= Value2，比较Value1和Value3
	                IF #Map.IN_RawValue1 > #Map.IN_RawValue3 THEN
	                    #RawValue := #Map.IN_RawValue1; // Value1是中值
	                ELSIF #Map.IN_RawValue2 > #Map.IN_RawValue3 THEN
	                    #RawValue := #Map.IN_RawValue3; // Value3是中值
	                ELSE
	                    #RawValue := #Map.IN_RawValue2; // Value2是中值
	                END_IF;
	            END_IF;
	        ELSE
	            // 不启用3取2功能时，使用传感器1的值
	            #RawValue := #Map.IN_RawValue1;
	        END_IF;
	    END_REGION
	    
	    REGION 量程转换
	        // 转换三个传感器的工程值
	        IF (#Keep.IN_RawHigh - #Keep.IN_RawLow) <> 0 THEN
	            #Temp.OUT_EngValue1 := INT_TO_REAL(#Map.IN_RawValue1 - #Keep.IN_RawLow) * (#Keep.IN_EngHigh - #Keep.IN_EngLow) / INT_TO_REAL(#Keep.IN_RawHigh - #Keep.IN_RawLow) + #Keep.IN_EngLow;
	            #Temp.OUT_EngValue2 := INT_TO_REAL(#Map.IN_RawValue2 - #Keep.IN_RawLow) * (#Keep.IN_EngHigh - #Keep.IN_EngLow) / INT_TO_REAL(#Keep.IN_RawHigh - #Keep.IN_RawLow) + #Keep.IN_EngLow;
	            #Temp.OUT_EngValue3 := INT_TO_REAL(#Map.IN_RawValue3 - #Keep.IN_RawLow) * (#Keep.IN_EngHigh - #Keep.IN_EngLow) / INT_TO_REAL(#Keep.IN_RawHigh - #Keep.IN_RawLow) + #Keep.IN_EngLow;
	        END_IF;
	        
	        IF #Temp.IN_SimMode THEN
	            // 模拟模式：使用手动设定值
	            #HMI.OUT_EngValue := #Temp.IN_ManualValue;
	        ELSE
	            // 自动模式：使用传感器值
	            #HMI.OUT_EngValue := INT_TO_REAL(#RawValue - #Keep.IN_RawLow) * (#Keep.IN_EngHigh - #Keep.IN_EngLow) / INT_TO_REAL(#Keep.IN_RawHigh - #Keep.IN_RawLow) + #Keep.IN_EngLow;
	        END_IF;
	    END_REGION
	    
	    REGION 报警处理
	        // 报警使能和延时处理
	        IF #Keep.IN_ALMEnable THEN
	            // 启动报警延时定时器
	            #AlarmTimer.IN := TRUE;
	            #AlarmTimer.PT := #Keep.IN_AlarmDelay;
	        ELSE
	            // 报警未使能时，复位所有报警状态
	            #AlarmTimer.IN := FALSE;
	            #HHAlarmTimer.IN := FALSE;
	            #LLAlarmTimer.IN := FALSE;
	            #HAlarmTimer.IN := FALSE;
	            #LAlarmTimer.IN := FALSE;
	            #ALM.OUT_HHAlarm := FALSE;
	            #PreAlarm.OUT_HPreAlarm := FALSE;
	            #PreAlarm.OUT_LPreAlarm := FALSE;
	            #ALM.OUT_LLAlarm := FALSE;
	            #ALM.OUT_SensorFault1 := FALSE;
	            #ALM.OUT_SensorFault2 := FALSE;
	            #ALM.OUT_SensorFault3 := FALSE;
	            #PreAlarm.OUT_wPreAlarm := 0;
	            #ALM.OUT_wInterlock := 0;
	        END_IF;
	    END_REGION
	    
	    REGION 报警字和状态字更新
	        // 故障复位处理 - 直接复位所有联锁报警，不判断条件
	        IF #IN_xALMREST THEN
	            #ALM.OUT_LLAlarm := FALSE;
	            #ALM.OUT_HHAlarm := FALSE;
	            #ALM.OUT_SensorFault1 := FALSE;
	            #ALM.OUT_SensorFault2 := FALSE;
	            #ALM.OUT_SensorFault3 := FALSE;
	        END_IF;
	        
	        // 报警条件判断和延时处理
	        IF #Keep.IN_ALMEnable THEN
	            // 传感器故障检测和状态更新
	            IF #AlarmTimer.Q THEN
	                #ALM.OUT_SensorFault1 := (#Map.IN_RawValue1 > #Keep.IN_SensorFaultHigh) OR (#Map.IN_RawValue1 < #Keep.IN_SensorFaultLow);
	                #ALM.OUT_SensorFault2 := (#Map.IN_RawValue2 > #Keep.IN_SensorFaultHigh) OR (#Map.IN_RawValue2 < #Keep.IN_SensorFaultLow);
	                #ALM.OUT_SensorFault3 := (#Map.IN_RawValue3 > #Keep.IN_SensorFaultHigh) OR (#Map.IN_RawValue3 < #Keep.IN_SensorFaultLow);
	            END_IF;
	            
	            // 高高报警条件判断和状态更新（需要手动复位）
	            IF #Keep.IN_AlarmMask.%X0 AND #HMI.OUT_EngValue >= #Keep.IN_HHLimit THEN
	                // 启动高高报警延时定时器
	                #HHAlarmTimer.IN := TRUE;
	                #HHAlarmTimer.PT := #Keep.IN_AlarmDelay;
	                IF #HHAlarmTimer.Q THEN
	                    #ALM.OUT_HHAlarm := TRUE;
	                END_IF;
	            ELSE
	                #HHAlarmTimer.IN := FALSE;
	                // 手动复位，不需要检测死区
	                #ALM.OUT_HHAlarm := #ALM.OUT_HHAlarm AND NOT #IN_xALMREST;
	            END_IF;
	            
	            // 高报警条件判断和状态更新（自动复位）
	            IF #Keep.IN_AlarmMask.%X1 AND #HMI.OUT_EngValue >= #Keep.IN_HLimit THEN
	                // 启动高报警延时定时器
	                #HAlarmTimer.IN := TRUE;
	                #HAlarmTimer.PT := #Keep.IN_AlarmDelay;
	                IF #HAlarmTimer.Q THEN
	                    #PreAlarm.OUT_HPreAlarm := TRUE;
	                END_IF;
	            ELSE
	                #HAlarmTimer.IN := FALSE;
	                // 自动复位，需要检测死区
	                IF #HMI.OUT_EngValue <= (#Keep.IN_HLimit - #Keep.IN_DeadBand) THEN
	                    #PreAlarm.OUT_HPreAlarm := FALSE;
	                END_IF;
	            END_IF;
	            
	            // 低报警条件判断和状态更新（自动复位）
	            IF #Keep.IN_AlarmMask.%X2 AND #HMI.OUT_EngValue <= #Keep.IN_LLimit THEN
	                // 启动低报警延时定时器
	                #LAlarmTimer.IN := TRUE;
	                #LAlarmTimer.PT := #Keep.IN_AlarmDelay;
	                IF #LAlarmTimer.Q THEN
	                    #PreAlarm.OUT_LPreAlarm := TRUE;
	                END_IF;
	            ELSE
	                #LAlarmTimer.IN := FALSE;
	                // 自动复位，需要检测死区
	                IF #HMI.OUT_EngValue >= (#Keep.IN_LLimit + #Keep.IN_DeadBand) THEN
	                    #PreAlarm.OUT_LPreAlarm := FALSE;
	                END_IF;
	            END_IF;
	            
	            // 低低报警条件判断和状态更新（需要手动复位）
	            IF #Keep.IN_AlarmMask.%X3 AND #HMI.OUT_EngValue <= #Keep.IN_LLLimit THEN
	                // 启动低低报警延时定时器
	                #LLAlarmTimer.IN := TRUE;
	                #LLAlarmTimer.PT := #Keep.IN_AlarmDelay;
	                IF #LLAlarmTimer.Q THEN
	                    #ALM.OUT_LLAlarm := TRUE;
	                END_IF;
	            ELSE
	                #LLAlarmTimer.IN := FALSE;
	                // 手动复位，不需要检测死区
	                #ALM.OUT_LLAlarm := #ALM.OUT_LLAlarm AND NOT #IN_xALMREST;
	            END_IF;
	        ELSE
	            // 报警未使能或延时未到时，清除所有报警状态
	            #ALM.OUT_SensorFault1 := FALSE;
	            #ALM.OUT_SensorFault2 := FALSE;
	            #ALM.OUT_SensorFault3 := FALSE;
	            #ALM.OUT_HHAlarm := FALSE;
	            #PreAlarm.OUT_HPreAlarm := FALSE;
	            #PreAlarm.OUT_LPreAlarm := FALSE;
	            #ALM.OUT_LLAlarm := FALSE;
	        END_IF;
	        
	        // 更新预警字（高报警和低报警）
	        #PreAlarm.OUT_wPreAlarm := 0;
	        #PreAlarm.OUT_wPreAlarm.%X0 := #PreAlarm.OUT_HPreAlarm;  // 高预警
	        #PreAlarm.OUT_wPreAlarm.%X1 := #PreAlarm.OUT_LPreAlarm;  // 低预警
	        
	        // 更新联锁字（高高报警、低低报警和传感器故障）
	        #ALM.OUT_wInterlock := 0;
	        #ALM.OUT_wInterlock.%X0 := #ALM.OUT_HHAlarm;      // 高高报警
	        #ALM.OUT_wInterlock.%X1 := #ALM.OUT_LLAlarm;      // 低低报警
	        #ALM.OUT_wInterlock.%X2 := #ALM.OUT_SensorFault1; // 传感器1故障
	        #ALM.OUT_wInterlock.%X3 := #ALM.OUT_SensorFault2; // 传感器2故障
	        #ALM.OUT_wInterlock.%X4 := #ALM.OUT_SensorFault3; // 传感器3故障
	        
	        // 状态字处理逻辑，按优先级排序
	        IF (#ALM.OUT_SensorFault1 OR #ALM.OUT_SensorFault2 OR #ALM.OUT_SensorFault3) AND #Keep.IN_ALMEnable THEN
	            #HMI.OUT_uiState := #ANA_STATE_SENSOR_FAULT;  // 传感器故障，最高优先级
	        ELSIF #ALM.OUT_HHAlarm THEN
	            #HMI.OUT_uiState := #ANA_STATE_HH_ALARM;  // 高高报警
	        ELSIF #ALM.OUT_LLAlarm THEN
	            #HMI.OUT_uiState := #ANA_STATE_LL_ALARM;  // 低低报警，调整为高于低报警的优先级
	        ELSIF #PreAlarm.OUT_HPreAlarm THEN
	            #HMI.OUT_uiState := #ANA_STATE_H_ALARM;  // 高报警
	        ELSIF #PreAlarm.OUT_LPreAlarm THEN
	            #HMI.OUT_uiState := #ANA_STATE_L_ALARM;  // 低报警
	        ELSE
	            #HMI.OUT_uiState := #ANA_STATE_NORMAL;  // 正常状态
	        END_IF;
	    END_REGION
	    
END_FUNCTION_BLOCK

